{"version":3,"sources":["webpack://app_lista_tareas/webpack/bootstrap","webpack://app_lista_tareas/webpack/runtime/define property getters","webpack://app_lista_tareas/webpack/runtime/hasOwnProperty shorthand","webpack://app_lista_tareas/./src/js/classes/tarea.class.js","webpack://app_lista_tareas/./src/js/componentes.js","webpack://app_lista_tareas/./src/index.js","webpack://app_lista_tareas/./src/js/classes/listatareas.class.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Tarea","constructor","tarea","this","id","Date","getTime","completado","fecha","nuevaTarea","document","querySelector","ul","borrarCompletados","filtros","filtrosMarco","querySelectorAll","footer","numPendHTML","anadirTareaHTML","tareasHTML","innerHTML","mostrarFooter","listaTareas","length","classList","remove","add","mostrarPendientes","contarPendientes","filter","textContent","mostrarBorrarCompletadas","addEventListener","evento","value","trim","nuevaTareaCreada","anadirTarea","nombreElemento","target","localName","tareaSeleccionada","parentElement","tareaId","dataset","marcarCompletado","toggle","eliminarTarea","removeChild","eliminarCompletados","index","children","elemento","contains","forEach","filtro","textoFiltroSeleccionado","text","etiquetaSeleccionada","console","log","setAttribute","textoLabel","removeAttribute","guardarLocalStorage","cargarLocalStorage","push","localStorage","setItem","JSON","stringify","getItem","parse"],"mappings":"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","file":"bundle.5dcf2c90727dd0743169.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Clases que necesito\r\n// Vamos a tener una clase que es la tarea, que esta recibirá una tarea nueva y a partir de ahí, una serie de datos.\r\nexport class Tarea {\r\n    constructor(tarea) {\r\n        this.tarea = tarea;\r\n\r\n        // Necesitaremos un identificador único para cada tarea.\r\n        this.id = new Date().getTime();\r\n        // Necesitamos saber si las tareas están completas o no.\r\n        this.completado = false;\r\n        this.fecha = new Date();\r\n    }\r\n}","import { Tarea} from \"./classes/index\";\r\nimport { listaTareas } from \"../index\";\r\n\r\n// Variables cogidas del DOM/HTML\r\n// Cojo el input donde escribimos las tareas.\r\nconst nuevaTarea = document.querySelector('.new-todo');\r\n// Cojo el padre de las li, que es el elemento ul.\r\nconst ul = document.querySelector('.todo-list');\r\n// Cojo el botón de eliminar completados del HTML.\r\nconst borrarCompletados = document.querySelector('.clear-completed');\r\n// Cojo la lista donde se encuentran los botones que realizan los filtros.\r\nconst filtros = document.querySelector('.filters');\r\n// Cojo cada uno de los filtros para poder recorrer el vector.\r\nconst filtrosMarco = document.querySelectorAll('.filtro');\r\n\r\n// Cojo el footer para ocultarlo cuando no hay ninguna tarea.\r\nconst footer = document.querySelector('.footer');\r\n// Cojo el strong donde se muestran el número de tareas pendientes.\r\nlet numPendHTML = document.querySelector('strong');\r\n\r\n// Funciones\r\n// Función que sirve para que cuando escribamos una tarea se renderice en el HTML.\r\nexport const anadirTareaHTML = (tarea) => {\r\n\r\n    const tareasHTML = `\r\n        <li class=\"${(tarea.completado) ? 'completed' : ''}\" data-id=\"${tarea.id}\">\r\n            <div class=\"view\">\r\n                <input class=\"toggle\" type=\"checkbox\" ${(tarea.completado) ? 'checked' : ''}>\r\n                <label>${tarea.tarea}</label>\r\n                <button class=\"destroy\"></button>\r\n            </div>\r\n            <input class=\"edit\" value=\"Create a TodoMVC template\">\r\n        </li>\r\n    `;\r\n    ul.innerHTML += tareasHTML;\r\n};\r\n// Función que muestra y oculta el footer si hay tareas o no.\r\nexport const mostrarFooter = () => {\r\n    // Si hay algo en la lista de taras, lo muestra. Y si no, lo oculta.\r\n    if (listaTareas.listaTareas.length !== 0) {\r\n        footer.classList.remove('hidden');\r\n    } else {\r\n        footer.classList.add('hidden');\r\n    }\r\n\r\n}\r\n// Función que muestra y oculta el número de elementos pendientes en un span dentro del footer.\r\nexport const mostrarPendientes = () => {\r\n    const contarPendientes = listaTareas.listaTareas.filter((tarea) => tarea.completado === false);\r\n    numPendHTML.textContent = contarPendientes.length;\r\n};\r\n// Función que muestra el botón de eliminar completadas cuando hay taras ya hechas.\r\nexport const mostrarBorrarCompletadas = () => {\r\n    const hayCompletadas = listaTareas.listaTareas.filter((tarea) => tarea.completado === true);\r\n    (hayCompletadas.length > 0) ? (borrarCompletados.classList.remove('hidden')) : (borrarCompletados.classList.add('hidden'));\r\n}\r\n// Eventos\r\n// Evento que al pulsa la tecla Enter crea la tarea, añade la tarea al HTML y la añade a la lista de tareas.\r\nnuevaTarea.addEventListener('keyup', (evento) => {\r\n\r\n    // Hacemos una condición que será si se pulsa la tecla Enter y si hay contenido dentro del cuadro de tipo texto.\r\n    // Eliminar los espacios al inicio y al final.\r\n    if (evento.key === 'Enter' && nuevaTarea.value.trim().length > 0) {\r\n        // Creo una nueva instancia a la tarea.\r\n        const nuevaTareaCreada = new Tarea(nuevaTarea.value);\r\n        // Añadimos la nueva tarea al vector.\r\n        listaTareas.anadirTarea(nuevaTareaCreada);\r\n        // Añadimos la tarea al HTML.\r\n        anadirTareaHTML(nuevaTareaCreada);\r\n        // Borramos el contenido del input de texto.\r\n        nuevaTarea.value = '';\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n});\r\n// Evento que al marcar los elementos como completados y da funcionalidad al botón de borrar.\r\nul.addEventListener('click', (evento) => {\r\n    // Hacemos click en una de las partes del texto y tenemos que saber donde pulsamos, tenemos una propiedad en el target que se llama\r\n    // localName que nos va a decir dónde pulsamos, podremos pulsar en el checkbox, en el lable o en el botón de eliminar, pues tendremos que hacer\r\n    // condiciones según donde pulsemos.\r\n    const nombreElemento = evento.target.localName;\r\n    // Tengo que coger la li donde hago clic para que cuando pulsemos el botón de eliminar, borre toda la tarea.\r\n    const tareaSeleccionada = evento.target.parentElement.parentElement;\r\n    // Cojo el id único de cada una de las tareas, este id está en el atributo de HTML data-id.\r\n    const tareaId = tareaSeleccionada.dataset.id;\r\n    //const tareaId = tareaSeleccionada.getAttribute('data-id');\r\n\r\n    // Una vez que tenemos toda la información haremos un condicional, si se pulsa en el check se llama al método marcarCompletado.\r\n    // se pulsa el botón de eliminar se llama al método de eliminarTarea.\r\n    if (nombreElemento === 'input') {\r\n        listaTareas.marcarCompletado(tareaId);\r\n        // En la consola vemos que va cambiando la propiedad completado pero no tacha la tarea, para hacer eso tenemos que jugar\r\n        // con las clases y añadirle y quitarle la clase completed al li.\r\n        tareaSeleccionada.classList.toggle('completed');\r\n    }\r\n    if (nombreElemento === 'button') {\r\n        listaTareas.eliminarTarea(tareaId);\r\n        ul.removeChild(tareaSeleccionada);\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n});\r\n// Eliminar completados.\r\nborrarCompletados.addEventListener('click', () => {\r\n    // Llamamos al método de la clase eliminarCompletados.\r\n    listaTareas.eliminarCompletados();\r\n    // Recorremos la ul donde están los li, esta es un vector y con la propiedad children puedo sacar el número de elementos.\r\n    // Tendremos que recorrer el vector al revés desde el último elemento al primero, porque si lo recorremos del inicio al final,\r\n    // como se borra un elemento, las posiciones del vector ya no coinciden.\r\n    for (let index = ul.children.length - 1; index >= 0; index--) {\r\n        // Guardo lo que hay en cada una de las posiciones en una variable.\r\n        const elemento = ul.children[index];\r\n        // Hago un condicional en el que le digo si contiene la clase completed, si es verdad lo elimino de la lista.\r\n        if (elemento.classList.contains('completed')) {\r\n            elemento.remove();\r\n        }\r\n    }\r\n    mostrarFooter();\r\n    mostrarPendientes();\r\n    mostrarBorrarCompletadas();\r\n});\r\n\r\n// Evento para seleccionar los elementos completados y no completados.\r\nfiltros.addEventListener('click', (evento) => {\r\n    // Recorremos las a y le quitamos el cuadrado cuando pulsamos en cualquier lado de la ul\r\n    filtrosMarco.forEach((filtro) => filtro.classList.remove('selected'));\r\n    // Ponemos el marco en el elemento seleccionado.\r\n    evento.target.classList.add('selected');\r\n    // Ponemos el texto que tiene el elemento seleccionado en una variable y después hacemos un switch\r\n    // para cada uno de los casos.\r\n    const textoFiltroSeleccionado = evento.target.text;\r\n    // Podríamos añadir una medida de seguridad y es que si pulso donde no hay elemento,\r\n    // o sea, la constante textoFiltroSeleccionado está vacía que salga del evento.\r\n    if (!textoFiltroSeleccionado) { return }\r\n    // Tenemos que recorrer el vector donde se encuentran las lipara saber cuáles están completados y cuáles no.\r\n    for (const elemento of ul.children) {\r\n        // El primer paso es quitar a todos los elementos la clase hidden por que si no,\r\n        // el filtro del switch se lo asigna y se quita, además nos servirá para que funcione el botón\r\n        // de Tareas, ya que mostrará todas ellas.\r\n        elemento.classList.remove('hidden');\r\n        // Según el botón que yo pulse ocultará las completadas o las que no.\r\n        switch (textoFiltroSeleccionado) {\r\n            case 'Pendientes':\r\n                // Comprobamos si el elemento seleccionado tiene la clase \"complete\". Si es así, le asignamos\r\n                // la clase CSS hidden que oculta los elementos con el display: none.\r\n                if (elemento.classList.contains('completed')) {\r\n                    elemento.classList.add('hidden');\r\n                }\r\n                break;\r\n            case 'Completadas':\r\n                // Comprobamos si el elemento seleccionado no tiene la clase \"complete\". Si es así, le asignamos\r\n                // la clase CSS hidden que oculta los elementos con el display: none.\r\n                if (!elemento.classList.contains('completed')) {\r\n                    elemento.classList.add('hidden');\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n});\r\n// Añado el evento que al hacer doble clic sobre una label automáticamente la pueda modificar añadiendo el\r\n// atributo contentEditable=\"true\".\r\nul.addEventListener('dblclick', (evento) => {\r\n    const nombreElemento = evento.target.localName;\r\n    const tareaSeleccionada = evento.target.parentElement.parentElement;\r\n    const tareaId = tareaSeleccionada.dataset.id;\r\n    // Accedenis a la label que hemos pulsado y le ponemos el contentEditable = true\r\n    if( nombreElemento === 'label'){\r\n       const etiquetaSeleccionada = tareaSeleccionada.children[0].children[1];\r\n       console.log(etiquetaSeleccionada);\r\n       etiquetaSeleccionada.setAttribute('contenteditable', true);\r\n       etiquetaSeleccionada.setAttribute('style', 'border:1px solid #000000');\r\n       // Una vez que editamos la etiqueta, ponemos el evento para que cuando pulsemos la tecla enter deje de ser editable.\r\n       etiquetaSeleccionada.addEventListener('keypress', (evento) => {\r\n            if(evento.key === 'Enter'){\r\n                // Tenemos que coger el valor que hay dentro de la etiqueta y guardarlo en una constante para modificarlo en el vector.\r\n                const textoLabel = etiquetaSeleccionada.innerHTML;\r\n                console.log(textoLabel);\r\n                etiquetaSeleccionada.setAttribute('contenteditable', false);\r\n                etiquetaSeleccionada.removeAttribute('style');\r\n                // Tendremos que modificar la tarea que hemos editado usando su id.\r\n                listaTareas.listaTareas.forEach((tarea) => {\r\n                    // Lo que hay en el atributo es texto y lo que hay en la clase es un número.\r\n                    if(tarea.id == tareaId){\r\n                        tarea.tarea = textoLabel;\r\n                        // Faltaría actualizar el local Storage\r\n                        listaTareas.guardarLocalStorage();\r\n                    }\r\n                });\r\n            }\r\n       });\r\n    }\r\n});","// Importamos el CSS desde la carpeta donde se encuentra.\r\nimport './css/style.css';\r\n\r\n// Importamos la clase que necesitamos.\r\nimport { ListaTareas } from './js/classes/index';\r\n\r\n// Importamos las funciones que necesita para que funcione la aplicación.\r\nimport {anadirTareaHTML, mostrarFooter, mostrarPendientes, mostrarBorrarCompletadas} from './js/componentes'\r\n\r\n// Llamadas a las funciones\r\nexport const listaTareas = new ListaTareas();\r\n// Tengo que llamar a la función que dibuja el HTML.\r\nlistaTareas.listaTareas.forEach((tarea) => anadirTareaHTML(tarea));\r\nmostrarFooter();\r\nmostrarPendientes();\r\nmostrarBorrarCompletadas();\r\n\r\n","// Crearemos otra clase que guarde la lista de tareas y en la que se puedan realizar varios métodos, como añadir elementos, eliminar elementos, eliminar todos, etc.\r\nexport class ListaTareas {\r\n    constructor() {\r\n        // El constructor va a ser un vector en el cual se almacenan todas las tareas que se crean e inicialmente está vacía.\r\n        //this.listaTareas = [];\r\n        this.cargarLocalStorage();\r\n    }\r\n    // El primer método que tiene que existir es el de añadir elementos a la lista de tareas.\r\n    anadirTarea(tarea) {\r\n        this.listaTareas.push(tarea);\r\n        console.log(this.listaTareas);\r\n        this.guardarLocalStorage();\r\n    }\r\n    // Otro método será el de eliminar el elemento seleccionado de la lista de tareas.\r\n    eliminarTarea(id) {\r\n        this.listaTareas = this.listaTareas.filter((tarea) => tarea.id != id);\r\n        this.guardarLocalStorage();\r\n    }\r\n    // Otro método que será el de eliminar todos los elementos que hemos completado.\r\n    eliminarCompletados() {\r\n        // Filtraremos todos los elementos que no tengan this.completado = true.\r\n        this.listaTareas = this.listaTareas.filter((tarea) => tarea.completado == false);\r\n        this.guardarLocalStorage();\r\n    }\r\n    marcarCompletado(id) {\r\n        // Para marcar completado tendré que recorrer el vector y comprobar cada uno de los id con el que recibiré del evento y cuando coincidan\r\n        // le tengo que cambiar el estado.\r\n        for (const tarea of this.listaTareas) {\r\n            if (tarea.id == id) {\r\n                // En tarea.id voy a tener un número que es el que se crea automáticamente cuando creamos la tarea\r\n                // que estará guardado en el atributo data-id.\r\n                // Cuando pulso en el checkbox, cambiará de estado, si está en true, a false y si es false, a true.\r\n                tarea.completado = !tarea.completado;\r\n\r\n                this.guardarLocalStorage();\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n    guardarLocalStorage() {\r\n        localStorage.setItem('tareas', JSON.stringify(this.listaTareas));\r\n    }\r\n    cargarLocalStorage() {\r\n        // Cuando cargamos datos del local Storage tenemos dos posibilidades, si no hay nada, creamos un vector\r\n        // vacío, y si hay algo, cargamos los datos del local. Esto servirá para que en el constructor llamemos\r\n        // a esta función.\r\n        // if(localStorage.getItem(this.key)){\r\n        //     this.listaTareas = JSON.parse(localStorage.getItem(this.key));\r\n        // } else {\r\n        //     this.listaTareas = [];\r\n        // }\r\n        this.listaTareas = (localStorage.getItem('tareas')) ? (JSON.parse(localStorage.getItem('tareas'))) : ([]);\r\n\r\n    }\r\n}"],"sourceRoot":""}